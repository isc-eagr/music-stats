<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <!-- This fragment provides reusable unmatched scrobbles modal functionality -->
</head>
<body>
    <!-- Unmatched Scrobbles Modal Styles -->
    <th:block th:fragment="modal-styles">
        <style>
            /* Modal base styles */
            .unmatched-modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center; }
            .unmatched-modal.active { display: flex; }
            .unmatched-modal-content { background-color: #1a1a1a; border-radius: 8px; width: 90%; max-width: 900px; max-height: 90vh; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
            .unmatched-modal-header { display: flex; justify-content: space-between; align-items: center; padding: 20px; border-bottom: 1px solid #333; }
            .unmatched-modal-header h2 { margin: 0; color: #fff; font-size: 18px; }
            .unmatched-modal-close { color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; transition: color 0.2s; }
            .unmatched-modal-close:hover { color: #fff; }
            .unmatched-modal-body { padding: 20px; }
            .unmatched-modal-footer { display: flex; gap: 10px; padding: 20px; border-top: 1px solid #333; justify-content: flex-end; }
            
            /* Wizard steps */
            .wizard-steps { display: flex; gap: 8px; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid #333; }
            .wizard-step { display: flex; align-items: center; gap: 8px; padding: 8px 16px; border-radius: 20px; background: #2a2a2a; color: #888; font-size: 13px; }
            .wizard-step.active { background: var(--success, #22c55e); color: #fff; }
            .wizard-step.completed { background: #2d4a2d; color: #8f8; }
            .wizard-step-number { width: 20px; height: 20px; border-radius: 50%; background: #444; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: bold; }
            .wizard-step.active .wizard-step-number { background: rgba(255,255,255,0.2); }
            .wizard-step.completed .wizard-step-number { background: #4a8; }
            
            /* Unmatched list table */
            .unmatched-table { width: 100%; border-collapse: collapse; }
            .unmatched-table th, .unmatched-table td { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.06); text-align: left; }
            .unmatched-table th { color: var(--text-muted, #888); font-weight: 600; font-size: 12px; text-transform: uppercase; }
            .unmatched-table .count { text-align: right; font-weight: 700; }
            .unmatched-table .actions { text-align: center; white-space: nowrap; }
            .unmatched-table .actions .btn { padding: 4px 10px; font-size: 11px; margin: 0 2px; }
            
            /* Scrobble info display */
            .scrobble-info { background: #222; padding: 12px; border-radius: 6px; margin-bottom: 16px; }
            .scrobble-info p { margin: 4px 0; color: #ccc; font-size: 14px; }
            .scrobble-info strong { color: #fff; }
            
            /* Form sections */
            .wizard-section { display: none; }
            .wizard-section.active { display: block; }
            .form-group { margin-bottom: 16px; }
            .form-group label { display: block; margin-bottom: 6px; color: #ccc; font-size: 14px; }
            .form-group input, .form-group select { width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; color: #fff; font-size: 14px; }
            .form-group input:focus, .form-group select:focus { outline: none; border-color: var(--success, #22c55e); }
            
            /* Search with button */
            .search-row { display: flex; gap: 8px; }
            .search-row input { flex: 1; }
            .search-row button { padding: 10px 16px; }
            
            /* Search results */
            .search-results { max-height: 200px; overflow-y: auto; border: 1px solid #333; border-radius: 6px; margin-top: 8px; }
            .search-result-item { padding: 10px 12px; border-bottom: 1px solid #333; cursor: pointer; transition: background 0.2s; }
            .search-result-item:last-child { border-bottom: none; }
            .search-result-item:hover { background: #2a2a2a; }
            .search-result-item.selected { background: #3a3a3a; border-left: 3px solid var(--success, #22c55e); }
            .result-name { font-weight: 600; color: #fff; }
            .result-meta { font-size: 12px; color: #888; margin-top: 2px; }
            .no-results { padding: 20px; text-align: center; color: #666; }
            
            /* Create new option */
            .create-new-option { padding: 12px; background: #1e3a1e; border: 1px dashed #4a8; border-radius: 6px; margin-top: 8px; cursor: pointer; transition: all 0.2s; }
            .create-new-option:hover { background: #2a4a2a; border-color: #6c6; }
            .create-new-option.selected { background: #2d5a2d; border-style: solid; }
            
            /* Navigation buttons */
            .wizard-nav { display: flex; justify-content: space-between; margin-top: 20px; padding-top: 16px; border-top: 1px solid #333; }
            .wizard-nav .btn-back { background: #444; }
            .wizard-nav .btn-back:hover { background: #555; }
            
            /* Disabled button styling */
            .btn:disabled, .btn-action:disabled {
                opacity: 0.4;
                cursor: not-allowed;
                pointer-events: none;
            }
        </style>
    </th:block>

    <!-- Unmatched Scrobbles List Modal -->
    <div th:fragment="unmatched-list-modal" id="unmatchedListModal" class="unmatched-modal">
        <div class="unmatched-modal-content" style="max-width: 1000px;">
            <div class="unmatched-modal-header">
                <h2>Unmatched Scrobbles</h2>
                <span class="unmatched-modal-close" onclick="closeUnmatchedListModal()">&times;</span>
            </div>
            <div class="unmatched-modal-body">
                <p style="color: #888; font-size: 14px; margin-bottom: 16px;">
                    These scrobbles could not be matched to existing songs. Use <strong>Create</strong> to add new artist/album/song, or <strong>Match</strong> to link to an existing song.
                </p>
                <div id="unmatchedListContainer">
                    <table class="unmatched-table">
                        <thead>
                            <tr>
                                <th>Artist</th>
                                <th>Album</th>
                                <th>Song</th>
                                <th class="count">Count</th>
                                <th class="actions">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="unmatchedListBody">
                            <!-- Populated via JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="unmatched-modal-footer">
                <button type="button" class="btn btn-negative" onclick="closeUnmatchedListModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Create Wizard Modal -->
    <div th:fragment="create-wizard-modal" id="createWizardModal" class="unmatched-modal">
        <div class="unmatched-modal-content">
            <div class="unmatched-modal-header">
                <h2>Create Song for Scrobbles</h2>
                <span class="unmatched-modal-close" onclick="closeCreateWizard()">&times;</span>
            </div>
            <div class="unmatched-modal-body">
                <!-- Wizard Steps Indicator -->
                <div class="wizard-steps">
                    <div class="wizard-step active" id="wizardStep1Indicator">
                        <span class="wizard-step-number">1</span>
                        <span>Artist</span>
                    </div>
                    <div class="wizard-step" id="wizardStep2Indicator">
                        <span class="wizard-step-number">2</span>
                        <span>Album</span>
                    </div>
                    <div class="wizard-step" id="wizardStep3Indicator">
                        <span class="wizard-step-number">3</span>
                        <span>Song</span>
                    </div>
                </div>

                <!-- Scrobble being processed -->
                <div class="scrobble-info" id="wizardScrobbleInfo">
                    <p><strong>Artist:</strong> <span id="wizardArtistName"></span></p>
                    <p><strong>Album:</strong> <span id="wizardAlbumName"></span></p>
                    <p><strong>Song:</strong> <span id="wizardSongName"></span></p>
                    <p><strong>Count:</strong> <span id="wizardScrobbleCount"></span> scrobbles</p>
                </div>

                <!-- Step 1: Artist Selection/Creation -->
                <div class="wizard-section active" id="wizardStep1">
                    <h3 style="color: #fff; margin-bottom: 12px;">Select or Create Artist</h3>
                    <div class="form-group">
                        <label>Search existing artists:</label>
                        <div class="search-row">
                            <input type="text" autocomplete="off" id="wizardArtistSearch" placeholder="Search artist name..." onkeyup="handleWizardArtistSearchKeyup(event)">
                            <button type="button" class="btn btn-action" onclick="searchWizardArtists()">Search</button>
                        </div>
                        <div class="search-results" id="wizardArtistResults">
                            <div class="no-results">Search for an existing artist or create a new one</div>
                        </div>
                    </div>
                    <div class="create-new-option" id="createNewArtistOption" onclick="toggleCreateNewArtist()">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 18px;">‚ûï</span>
                            <div>
                                <div style="color: #8f8; font-weight: 600;">Create New Artist</div>
                                <div style="color: #888; font-size: 12px;">Artist doesn't exist? Create it now.</div>
                            </div>
                        </div>
                    </div>
                    <div id="newArtistForm" style="display: none; margin-top: 12px; padding: 12px; background: #1e3a1e; border-radius: 6px;">
                        <div class="form-group">
                            <label>Artist Name *</label>
                            <div style="display: flex; gap: 8px;">
                                <input type="text" autocomplete="off" id="newArtistName" placeholder="Enter artist name" style="flex: 1;">
                                <button type="button" class="btn-fetch-external" onclick="openNewArtistExternalFetch()" title="Fetch birth/death date and country from MusicBrainz">
                                    Fetch External
                                </button>
                            </div>
                        </div>
                        <!-- Hidden fields for MusicBrainz data -->
                        <input type="hidden" id="newArtistBirthDate" value="">
                        <input type="hidden" id="newArtistDeathDate" value="">
                        <input type="hidden" id="newArtistIsBand" value="">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                            <div class="form-group">
                                <label>Gender *</label>
                                <select id="newArtistGender" required>
                                    <option value="">-- Select Gender --</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Language *</label>
                                <select id="newArtistLanguage" required>
                                    <option value="">-- Select Language --</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Genre *</label>
                                <select id="newArtistGenre" required>
                                    <option value="">-- Select Genre --</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Subgenre</label>
                                <select id="newArtistSubgenre">
                                    <option value="">-- Select Subgenre (optional) --</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Ethnicity *</label>
                                <select id="newArtistEthnicity" required>
                                    <option value="">-- Select Ethnicity --</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Country</label>
                                <select id="newArtistCountry">
                                    <option value="">-- Select Country (optional) --</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="wizard-nav">
                        <button type="button" class="btn btn-negative" onclick="closeCreateWizard()">Cancel</button>
                        <button type="button" class="btn btn-action" onclick="wizardNextStep(1)" id="wizardStep1Next" disabled>Next: Album ‚Üí</button>
                    </div>
                </div>

                <!-- Step 2: Album Selection/Creation -->
                <div class="wizard-section" id="wizardStep2">
                    <h3 style="color: #fff; margin-bottom: 12px;">Select or Create Album</h3>
                    <p style="color: #888; font-size: 13px; margin-bottom: 12px;">
                        Artist: <strong id="selectedArtistDisplay" style="color: #fff;"></strong>
                    </p>
                    <div class="form-group">
                        <label>Select from artist's albums:</label>
                        <select id="wizardAlbumSelect">
                            <option value="">-- No Album (Single) --</option>
                        </select>
                    </div>
                    <div class="create-new-option" id="createNewAlbumOption" onclick="toggleCreateNewAlbum()">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 18px;">‚ûï</span>
                            <div>
                                <div style="color: #8f8; font-weight: 600;">Create New Album</div>
                                <div style="color: #888; font-size: 12px;">Album doesn't exist? Create it now.</div>
                            </div>
                        </div>
                    </div>
                    <div id="newAlbumForm" style="display: none; margin-top: 12px; padding: 12px; background: #1e3a1e; border-radius: 6px;">
                        <div class="form-group">
                            <label>Album Name *</label>
                            <input type="text" autocomplete="off" id="newAlbumName" placeholder="Enter album name">
                        </div>
                        <div class="form-group">
                            <label>Release Date *</label>
                            <input type="text" autocomplete="off" id="newAlbumReleaseDate" placeholder="dd/mm/yyyy" required>
                        </div>
                        <div class="form-group" style="margin-top: 8px;">
                            <div style="display: flex; gap: 8px;">
                                <button type="button" class="btn btn-action btn-fetch-external-edit" id="wizardAlbumExternalSearchBtn" onclick="wizardSearchExternalForAlbum()" style="flex: 1;">
                                    External
                                </button>
                            </div>
                            <div id="wizardAlbumAppleStatus" style="color: #888; font-size: 12px; margin-top: 6px; text-align: center;"></div>
                        </div>
                        <!-- Album Image Preview -->
                        <div id="wizardAlbumImagePreview" style="display: none; margin-top: 12px; text-align: center;">
                            <img id="wizardAlbumImagePreviewImg" src="" style="max-width: 150px; max-height: 150px; border-radius: 6px; border: 2px solid #4CAF50;">
                            <input type="hidden" id="wizardAlbumImageUrl">
                        </div>
                    </div>
                    <div class="wizard-nav">
                        <button type="button" class="btn btn-back" onclick="wizardPrevStep(2)">‚Üê Back</button>
                        <button type="button" class="btn btn-action" onclick="wizardNextStep(2)">Next: Song ‚Üí</button>
                    </div>
                </div>

                <!-- Step 3: Song Creation -->
                <div class="wizard-section" id="wizardStep3">
                    <h3 style="color: #fff; margin-bottom: 12px;">Create Song</h3>
                    <p style="color: #888; font-size: 13px; margin-bottom: 12px;">
                        Artist: <strong id="selectedArtistDisplay2" style="color: #fff;"></strong><br>
                        Album: <strong id="selectedAlbumDisplay" style="color: #fff;"></strong>
                    </p>
                    <div class="form-group">
                        <label>Song Name *</label>
                        <input type="text" autocomplete="off" id="wizardSongNameInput" placeholder="Enter song name">
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        <div class="form-group">
                            <label>Release Date <span id="releaseDateOptionalLabel" style="color: #888; font-size: 11px;"></span></label>
                            <input type="text" autocomplete="off" id="wizardSongReleaseDate" placeholder="dd/mm/yyyy">
                        </div>
                        <div class="form-group">
                            <label>Length * (mm:ss)</label>
                            <div style="display: flex; gap: 8px;">
                                <input type="text" autocomplete="off" id="wizardSongLength" placeholder="3:45" pattern="[0-9]{1,2}:[0-5][0-9]" required style="flex: 1;">
                                <input type="hidden" id="wizardSongLengthSeconds">
                            </div>
                        </div>
                    </div>
                    <div class="form-group" style="margin-top: 8px;">
                        <div style="display: flex; gap: 8px;">
                            <button type="button" class="btn btn-action" id="wizardFetchItunesBtn" onclick="wizardFetchFromItunes()" style="flex: 1;">
                                üéµ Local iTunes
                            </button>
                            <button type="button" class="btn btn-action btn-fetch-external-edit" id="wizardSongExternalSearchBtn" onclick="wizardSearchExternalForSong()" style="flex: 1;">
                                External
                            </button>
                        </div>
                        <div id="wizardItunesFetchStatus" style="color: #888; font-size: 12px; margin-top: 6px; text-align: center;"></div>
                        <!-- Song Image Preview -->
                        <div id="wizardSongImagePreview" style="display: none; margin-top: 12px; text-align: center;">
                            <img id="wizardSongImagePreviewImg" src="" style="max-width: 100px; max-height: 100px; border-radius: 6px; border: 2px solid #4CAF50;">
                            <input type="hidden" id="wizardSongImageUrl">
                        </div>
                    </div>
                    <div class="wizard-nav">
                        <button type="button" class="btn btn-back" onclick="wizardPrevStep(3)">‚Üê Back</button>
                        <button type="button" class="btn btn-action" onclick="createAndAssignSong()" id="wizardCreateBtn">Create & Assign Scrobbles</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Match to Existing Song Modal -->
    <div th:fragment="match-modal" id="matchSongModal" class="unmatched-modal">
        <div class="unmatched-modal-content">
            <div class="unmatched-modal-header">
                <h2>Match to Existing Song</h2>
                <span class="unmatched-modal-close" onclick="closeMatchModal()">&times;</span>
            </div>
            <div class="unmatched-modal-body">
                <div class="scrobble-info" id="matchScrobbleInfo">
                    <p><strong>Artist:</strong> <span id="matchArtistName"></span></p>
                    <p><strong>Album:</strong> <span id="matchAlbumName"></span></p>
                    <p><strong>Song:</strong> <span id="matchSongName"></span></p>
                </div>
                
                <div class="form-group">
                    <label>Filter by artist:</label>
                    <div class="search-row">
                        <input type="text" autocomplete="off" id="matchArtistFilter" placeholder="Artist name (leave empty for all)" onkeyup="handleMatchSearchKeyup(event)">
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Search for song:</label>
                    <div class="search-row">
                        <input type="text" autocomplete="off" id="matchSongSearch" placeholder="Search by song name..." onkeyup="handleMatchSearchKeyup(event)">
                        <button type="button" class="btn btn-action" onclick="searchMatchSongs()">Search</button>
                    </div>
                </div>
                
                <div class="search-results" id="matchSongResults" style="max-height: 400px;">
                    <div class="no-results">Enter a search term and click Search</div>
                </div>
            </div>
            <div class="unmatched-modal-footer">
                <button type="button" class="btn btn-action" id="matchAssignBtn" onclick="assignMatchedSong()" disabled>Match</button>
                <button type="button" class="btn btn-negative" onclick="closeMatchModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- JavaScript for unmatched scrobbles modals -->
    <script th:fragment="modal-scripts">
        // State for wizard
        let wizardState = {
            scrobbleData: null,
            selectedArtistId: null,
            selectedArtistName: null,
            isNewArtist: false,
            selectedAlbumId: null,
            selectedAlbumName: null,
            isNewAlbum: false
        };
        
        // State for match modal
        let matchState = {
            scrobbleData: null,
            selectedSongId: null
        };
        
        // Unmatched list data (populated from import result or API)
        let unmatchedList = [];

        // ==================== Unmatched List Modal ====================
        function openUnmatchedListModal(data) {
            unmatchedList = data || [];
            renderUnmatchedList();
            document.getElementById('unmatchedListModal').classList.add('active');
        }
        
        function closeUnmatchedListModal() {
            document.getElementById('unmatchedListModal').classList.remove('active');
        }
        
        function renderUnmatchedList() {
            const tbody = document.getElementById('unmatchedListBody');
            if (!unmatchedList || unmatchedList.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #888; padding: 20px;">No unmatched scrobbles</td></tr>';
                return;
            }
            
            tbody.innerHTML = unmatchedList.map((row, index) => `
                <tr>
                    <td>${escapeHtml(row.artist || '')}</td>
                    <td>${escapeHtml(row.album || '')}</td>
                    <td>${escapeHtml(row.song || '')}</td>
                    <td class="count">${row.cnt || row.count || 0}</td>
                    <td class="actions">
                        <button class="btn btn-action" onclick="openCreateWizard(${index})">Create</button>
                        <button class="btn btn-secondary" onclick="openMatchModal(${index})">Match</button>
                    </td>
                </tr>
            `).join('');
        }

        // ==================== Create Wizard Modal ====================
        function openCreateWizard(index) {
            const row = unmatchedList[index];
            wizardState = {
                scrobbleData: row,
                selectedArtistId: null,
                selectedArtistName: null,
                isNewArtist: false,
                selectedAlbumId: null,
                selectedAlbumName: null,
                isNewAlbum: false
            };
            
            // Populate scrobble info
            document.getElementById('wizardArtistName').textContent = row.artist || '(none)';
            document.getElementById('wizardAlbumName').textContent = row.album || '(none)';
            document.getElementById('wizardSongName').textContent = row.song || '(none)';
            document.getElementById('wizardScrobbleCount').textContent = row.cnt || row.count || 0;
            
            // Pre-fill search fields
            document.getElementById('wizardArtistSearch').value = row.artist || '';
            document.getElementById('newArtistName').value = row.artist || '';
            document.getElementById('newAlbumName').value = row.album || '';
            document.getElementById('wizardSongNameInput').value = row.song || '';
            
            // Reset to step 1
            showWizardStep(1);
            resetWizardForms();
            
            // Load all dropdowns for new artist form
            loadAllArtistDropdowns();
            
            // Open modal
            document.getElementById('createWizardModal').classList.add('active');
            
            // Auto-search for artist
            if (row.artist) {
                searchWizardArtists();
            }
        }
        
        function closeCreateWizard() {
            document.getElementById('createWizardModal').classList.remove('active');
            wizardState = { scrobbleData: null, selectedArtistId: null, selectedArtistName: null, isNewArtist: false, selectedAlbumId: null, selectedAlbumName: null, isNewAlbum: false };
        }
        
        function showWizardStep(step) {
            // Update step indicators
            for (let i = 1; i <= 3; i++) {
                const indicator = document.getElementById(`wizardStep${i}Indicator`);
                const section = document.getElementById(`wizardStep${i}`);
                indicator.classList.remove('active', 'completed');
                section.classList.remove('active');
                
                if (i < step) {
                    indicator.classList.add('completed');
                } else if (i === step) {
                    indicator.classList.add('active');
                    section.classList.add('active');
                }
            }
        }
        
        function resetWizardForms() {
            document.getElementById('wizardArtistResults').innerHTML = '<div class="no-results">Search for an existing artist or create a new one</div>';
            document.getElementById('newArtistForm').style.display = 'none';
            document.getElementById('createNewArtistOption').classList.remove('selected');
            document.getElementById('newAlbumForm').style.display = 'none';
            document.getElementById('createNewAlbumOption').classList.remove('selected');
            document.getElementById('wizardStep1Next').disabled = true;
        }
        
        function loadGenders() {
            fetch('/genders/api/list')
                .then(r => r.json())
                .then(data => {
                    const select = document.getElementById('newArtistGender');
                    select.innerHTML = '<option value="">-- Select Gender --</option>';
                    data.forEach(g => {
                        select.innerHTML += `<option value="${g.id}">${escapeHtml(g.name)}</option>`;
                    });
                })
                .catch(err => console.error('Error loading genders:', err));
        }
        
        function loadLanguages() {
            fetch('/languages/api/list')
                .then(r => r.json())
                .then(data => {
                    const select = document.getElementById('newArtistLanguage');
                    select.innerHTML = '<option value="">-- Select Language --</option>';
                    data.forEach(l => {
                        select.innerHTML += `<option value="${l.id}">${escapeHtml(l.name)}</option>`;
                    });
                })
                .catch(err => console.error('Error loading languages:', err));
        }
        
        function loadGenres() {
            fetch('/genres/api/list')
                .then(r => r.json())
                .then(data => {
                    const select = document.getElementById('newArtistGenre');
                    select.innerHTML = '<option value="">-- Select Genre --</option>';
                    data.forEach(g => {
                        select.innerHTML += `<option value="${g.id}">${escapeHtml(g.name)}</option>`;
                    });
                })
                .catch(err => console.error('Error loading genres:', err));
        }
        
        function loadSubgenres() {
            fetch('/subgenres/api/list')
                .then(r => r.json())
                .then(data => {
                    const select = document.getElementById('newArtistSubgenre');
                    select.innerHTML = '<option value="">-- Select Subgenre (optional) --</option>';
                    data.forEach(sg => {
                        select.innerHTML += `<option value="${sg.id}">${escapeHtml(sg.name)}</option>`;
                    });
                })
                .catch(err => console.error('Error loading subgenres:', err));
        }
        
        function loadEthnicities() {
            fetch('/ethnicities/api/list')
                .then(r => r.json())
                .then(data => {
                    const select = document.getElementById('newArtistEthnicity');
                    select.innerHTML = '<option value="">-- Select Ethnicity --</option>';
                    data.forEach(e => {
                        select.innerHTML += `<option value="${e.id}">${escapeHtml(e.name)}</option>`;
                    });
                })
                .catch(err => console.error('Error loading ethnicities:', err));
        }
        
        function loadCountries() {
            fetch('/countries/api/list')
                .then(r => r.json())
                .then(data => {
                    const select = document.getElementById('newArtistCountry');
                    select.innerHTML = '<option value="">-- Select Country (optional) --</option>';
                    data.forEach(c => {
                        select.innerHTML += `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`;
                    });
                })
                .catch(err => console.error('Error loading countries:', err));
        }
        
        function loadAllArtistDropdowns() {
            loadGenders();
            loadLanguages();
            loadGenres();
            loadSubgenres();
            loadEthnicities();
            loadCountries();
        }
        
        function handleWizardArtistSearchKeyup(event) {
            if (event.key === 'Enter') searchWizardArtists();
        }
        
        function searchWizardArtists() {
            const query = document.getElementById('wizardArtistSearch').value.trim();
            if (!query) return;
            
            fetch(`/artists/api/search?q=${encodeURIComponent(query)}&limit=20`)
                .then(r => r.json())
                .then(data => {
                    const container = document.getElementById('wizardArtistResults');
                    if (!data || data.length === 0) {
                        container.innerHTML = '<div class="no-results">No artists found. Create a new one below.</div>';
                        return;
                    }
                    container.innerHTML = data.map(a => `
                        <div class="search-result-item" data-id="${a.id}" data-name="${escapeHtml(a.name)}" onclick="selectWizardArtist(${a.id}, '${escapeJs(a.name)}')">
                            <div class="result-name">${escapeHtml(a.name)}</div>
                            <div class="result-meta">${escapeHtml(a.genderName || '')} ${a.country ? '‚Ä¢ ' + escapeHtml(a.country) : ''}</div>
                        </div>
                    `).join('');
                })
                .catch(err => {
                    console.error('Error searching artists:', err);
                    document.getElementById('wizardArtistResults').innerHTML = '<div class="no-results">Error searching artists</div>';
                });
        }
        
        function selectWizardArtist(id, name) {
            // Deselect create new option
            document.getElementById('createNewArtistOption').classList.remove('selected');
            document.getElementById('newArtistForm').style.display = 'none';
            wizardState.isNewArtist = false;
            
            // Select this artist
            document.querySelectorAll('#wizardArtistResults .search-result-item').forEach(el => el.classList.remove('selected'));
            document.querySelector(`#wizardArtistResults .search-result-item[data-id="${id}"]`).classList.add('selected');
            
            wizardState.selectedArtistId = id;
            wizardState.selectedArtistName = name;
            document.getElementById('wizardStep1Next').disabled = false;
        }
        
        function toggleCreateNewArtist() {
            const option = document.getElementById('createNewArtistOption');
            const form = document.getElementById('newArtistForm');
            const isSelected = option.classList.toggle('selected');
            form.style.display = isSelected ? 'block' : 'none';
            
            // Deselect any existing artist
            document.querySelectorAll('#wizardArtistResults .search-result-item').forEach(el => el.classList.remove('selected'));
            
            if (isSelected) {
                wizardState.isNewArtist = true;
                wizardState.selectedArtistId = null;
                wizardState.selectedArtistName = document.getElementById('newArtistName').value;
                document.getElementById('wizardStep1Next').disabled = false;
            } else {
                wizardState.isNewArtist = false;
                document.getElementById('wizardStep1Next').disabled = true;
            }
        }
        
        // Open artist fetch modal to get birth/death date and country from MusicBrainz
        function openNewArtistExternalFetch() {
            const artistName = document.getElementById('newArtistName').value.trim();
            if (!artistName) {
                alert('Please enter an artist name first');
                return;
            }
            
            // Open the artist fetch modal with a callback to populate fields
            openArtistFetchModal(artistName, null, function(artistData) {
                // Populate hidden fields for birth/death dates
                document.getElementById('newArtistBirthDate').value = artistData.birthDate || '';
                document.getElementById('newArtistDeathDate').value = artistData.deathDate || '';
                document.getElementById('newArtistIsBand').value = (artistData.type === 'Group' || artistData.type === 'Orchestra' || artistData.type === 'Choir') ? 'true' : 'false';
                
                // Set country dropdown if we can find a match
                if (artistData.country) {
                    const countrySelect = document.getElementById('newArtistCountry');
                    const options = Array.from(countrySelect.options);
                    const match = options.find(opt => opt.text.toLowerCase() === artistData.country.toLowerCase());
                    if (match) {
                        countrySelect.value = match.value;
                    } else {
                        console.log('Country not found in dropdown:', artistData.country);
                    }
                }
                
                // Show a confirmation message
                const confirmMsg = [];
                if (artistData.birthDate) confirmMsg.push('Birth: ' + artistData.birthDate);
                if (artistData.deathDate) confirmMsg.push('Death: ' + artistData.deathDate);
                if (artistData.country) confirmMsg.push('Country: ' + artistData.country);
                if (artistData.type) confirmMsg.push('Type: ' + artistData.type);
                
                if (confirmMsg.length > 0) {
                    console.log('Applied MusicBrainz data:', confirmMsg.join(', '));
                }
            });
        }
        
        function wizardNextStep(currentStep) {
            if (currentStep === 1) {
                // Validate artist selection
                if (wizardState.isNewArtist) {
                    wizardState.selectedArtistName = document.getElementById('newArtistName').value.trim();
                    if (!wizardState.selectedArtistName) {
                        alert('Please enter an artist name');
                        return;
                    }
                    // Validate mandatory artist fields
                    const genderId = document.getElementById('newArtistGender').value;
                    const languageId = document.getElementById('newArtistLanguage').value;
                    const genreId = document.getElementById('newArtistGenre').value;
                    const ethnicityId = document.getElementById('newArtistEthnicity').value;
                    
                    if (!genderId) {
                        alert('Please select a gender for the artist');
                        return;
                    }
                    if (!languageId) {
                        alert('Please select a language for the artist');
                        return;
                    }
                    if (!genreId) {
                        alert('Please select a genre for the artist');
                        return;
                    }
                    if (!ethnicityId) {
                        alert('Please select an ethnicity for the artist');
                        return;
                    }
                } else if (!wizardState.selectedArtistId) {
                    alert('Please select an artist');
                    return;
                }
                
                // Update display and load albums
                document.getElementById('selectedArtistDisplay').textContent = wizardState.selectedArtistName;
                document.getElementById('selectedArtistDisplay2').textContent = wizardState.selectedArtistName;
                
                // Reset album selection
                wizardState.selectedAlbumId = null;
                wizardState.selectedAlbumName = null;
                wizardState.isNewAlbum = false;
                document.getElementById('newAlbumForm').style.display = 'none';
                document.getElementById('createNewAlbumOption').classList.remove('selected');
                
                // Clear album form fields
                document.getElementById('newAlbumName').value = wizardState.scrobbleData.album || '';
                document.getElementById('newAlbumReleaseDate').value = '';
                
                // Load albums if existing artist
                if (wizardState.selectedArtistId) {
                    loadArtistAlbums(wizardState.selectedArtistId);
                } else {
                    document.getElementById('wizardAlbumSelect').innerHTML = '<option value="">-- No Album (Single) --</option>';
                }
                
                showWizardStep(2);
            } else if (currentStep === 2) {
                // Validate album selection
                if (wizardState.isNewAlbum) {
                    wizardState.selectedAlbumName = document.getElementById('newAlbumName').value.trim();
                    if (!wizardState.selectedAlbumName) {
                        alert('Please enter an album name');
                        return;
                    }
                    // Validate release date for new album
                    const releaseDate = document.getElementById('newAlbumReleaseDate').value.trim();
                    if (!releaseDate) {
                        alert('Please enter a release date for the album');
                        return;
                    }
                    // Validate date format (dd/mm/yyyy)
                    if (!/^\d{2}\/\d{2}\/\d{4}$/.test(releaseDate)) {
                        alert('Please enter the release date in dd/mm/yyyy format');
                        return;
                    }
                    wizardState.newAlbumReleaseDate = releaseDate;
                } else {
                    const albumSelect = document.getElementById('wizardAlbumSelect');
                    wizardState.selectedAlbumId = albumSelect.value ? parseInt(albumSelect.value) : null;
                    wizardState.selectedAlbumName = albumSelect.value ? albumSelect.options[albumSelect.selectedIndex].text : '(Single)';
                    wizardState.newAlbumReleaseDate = null;
                }
                
                // Update display
                document.getElementById('selectedAlbumDisplay').textContent = wizardState.selectedAlbumName || '(Single)';
                
                // Update release date label based on whether an album is selected
                const releaseDateLabel = document.getElementById('releaseDateOptionalLabel');
                if (wizardState.selectedAlbumId || wizardState.isNewAlbum) {
                    releaseDateLabel.textContent = '(optional if same as album)';
                } else {
                    releaseDateLabel.textContent = '*';
                }
                
                // Clear song fields when entering step 3
                document.getElementById('wizardSongReleaseDate').value = '';
                document.getElementById('wizardSongLength').value = '';
                document.getElementById('wizardSongLengthSeconds').value = '';
                document.getElementById('wizardItunesFetchStatus').textContent = '';
                
                showWizardStep(3);
            }
        }
        
        function wizardPrevStep(currentStep) {
            showWizardStep(currentStep - 1);
        }
        
        function loadArtistAlbums(artistId) {
            fetch(`/albums/api/by-artist?artistId=${artistId}`)
                .then(r => r.json())
                .then(data => {
                    const select = document.getElementById('wizardAlbumSelect');
                    select.innerHTML = '<option value="">-- No Album (Single) --</option>';
                    data.forEach(album => {
                        const option = document.createElement('option');
                        option.value = album.id;
                        option.textContent = album.name;
                        select.appendChild(option);
                    });
                    
                    // Try to auto-select matching album
                    if (wizardState.scrobbleData && wizardState.scrobbleData.album) {
                        const match = data.find(a => a.name.toLowerCase() === wizardState.scrobbleData.album.toLowerCase());
                        if (match) {
                            select.value = match.id;
                        }
                    }
                })
                .catch(err => console.error('Error loading albums:', err));
        }
        
        function toggleCreateNewAlbum() {
            const option = document.getElementById('createNewAlbumOption');
            const form = document.getElementById('newAlbumForm');
            const isSelected = option.classList.toggle('selected');
            form.style.display = isSelected ? 'block' : 'none';
            wizardState.isNewAlbum = isSelected;
            
            if (isSelected) {
                document.getElementById('wizardAlbumSelect').value = '';
            }
        }
        
        function createAndAssignSong() {
            const songName = document.getElementById('wizardSongNameInput').value.trim();
            if (!songName) {
                alert('Please enter a song name');
                return;
            }
            
            // Validate song release date (only required if no album selected)
            const songReleaseDate = document.getElementById('wizardSongReleaseDate').value.trim();
            const hasAlbum = wizardState.selectedAlbumId || wizardState.isNewAlbum;
            
            if (!hasAlbum && !songReleaseDate) {
                alert('Please enter a release date for the song (required when no album is selected)');
                return;
            }
            if (songReleaseDate && !/^\d{2}\/\d{2}\/\d{4}$/.test(songReleaseDate)) {
                alert('Please enter the release date in dd/mm/yyyy format');
                return;
            }
            
            // Validate song length
            const songLength = document.getElementById('wizardSongLength').value.trim();
            if (!songLength) {
                alert('Please enter the song length');
                return;
            }
            if (!/^[0-9]{1,2}:[0-5][0-9]$/.test(songLength)) {
                alert('Please enter the length in mm:ss format (e.g., 3:45)');
                return;
            }
            
            // Convert mm:ss to seconds
            const [minutes, seconds] = songLength.split(':').map(Number);
            const lengthSeconds = minutes * 60 + seconds;
            
            const payload = {
                scrobbleArtist: wizardState.scrobbleData.artist,
                scrobbleAlbum: wizardState.scrobbleData.album,
                scrobbleSong: wizardState.scrobbleData.song,
                scrobbleAccount: wizardState.scrobbleData.account,
                
                artistId: wizardState.isNewArtist ? null : wizardState.selectedArtistId,
                newArtistName: wizardState.isNewArtist ? wizardState.selectedArtistName : null,
                newArtistGenderId: wizardState.isNewArtist ? (document.getElementById('newArtistGender').value || null) : null,
                newArtistLanguageId: wizardState.isNewArtist ? (document.getElementById('newArtistLanguage').value || null) : null,
                newArtistGenreId: wizardState.isNewArtist ? (document.getElementById('newArtistGenre').value || null) : null,
                newArtistSubgenreId: wizardState.isNewArtist ? (document.getElementById('newArtistSubgenre').value || null) : null,
                newArtistEthnicityId: wizardState.isNewArtist ? (document.getElementById('newArtistEthnicity').value || null) : null,
                newArtistCountry: wizardState.isNewArtist ? (document.getElementById('newArtistCountry').value || null) : null,
                newArtistBirthDate: wizardState.isNewArtist ? (document.getElementById('newArtistBirthDate').value || null) : null,
                newArtistDeathDate: wizardState.isNewArtist ? (document.getElementById('newArtistDeathDate').value || null) : null,
                newArtistIsBand: wizardState.isNewArtist ? (document.getElementById('newArtistIsBand').value === 'true' ? true : (document.getElementById('newArtistIsBand').value === 'false' ? false : null)) : null,
                
                albumId: wizardState.isNewAlbum ? null : wizardState.selectedAlbumId,
                newAlbumName: wizardState.isNewAlbum ? wizardState.selectedAlbumName : null,
                newAlbumReleaseDate: wizardState.isNewAlbum ? wizardState.newAlbumReleaseDate : null,
                newAlbumImageUrl: wizardState.newAlbumImageUrl || null,
                
                songName: songName,
                songReleaseDate: songReleaseDate,
                songLengthSeconds: lengthSeconds,
                songImageUrl: wizardState.newSongImageUrl || null
            };
            
            fetch('/scrobbles/api/create-and-assign', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    const importCount = wizardState.scrobbleData.cnt || wizardState.scrobbleData.count || 0;
                    let msg = `Success! Created song and assigned ${data.updatedCount} scrobble(s).`;
                    if (data.updatedCount > importCount) {
                        msg += `\n(${importCount} from this import + ${data.updatedCount - importCount} previously unmatched)`;
                    }
                    alert(msg);
                    // Refresh list BEFORE closing (so scrobbleData is still available)
                    refreshUnmatchedList();
                    closeCreateWizard();
                } else {
                    alert('Error: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(err => {
                console.error('Error creating and assigning:', err);
                alert('Error creating song');
            });
        }

        // ==================== Match Modal ====================
        function openMatchModal(index) {
            const row = unmatchedList[index];
            matchState = {
                scrobbleData: row,
                selectedSongId: null
            };
            
            document.getElementById('matchArtistName').textContent = row.artist || '(none)';
            document.getElementById('matchAlbumName').textContent = row.album || '(none)';
            document.getElementById('matchSongName').textContent = row.song || '(none)';
            document.getElementById('matchArtistFilter').value = row.artist || '';
            document.getElementById('matchSongSearch').value = row.song || '';
            document.getElementById('matchSongResults').innerHTML = '<div class="no-results">Enter a search term and click Search</div>';
            document.getElementById('matchAssignBtn').disabled = true;
            
            document.getElementById('matchSongModal').classList.add('active');
            
            // Auto-search using the artist and song
            if (row.artist || row.song) {
                searchMatchSongs();
            }
        }
        
        function closeMatchModal() {
            document.getElementById('matchSongModal').classList.remove('active');
            matchState = { scrobbleData: null, selectedSongId: null };
        }
        
        function handleMatchSearchKeyup(event) {
            if (event.key === 'Enter') searchMatchSongs();
        }
        
        function searchMatchSongs() {
            const artistFilter = document.getElementById('matchArtistFilter').value.trim();
            const songQuery = document.getElementById('matchSongSearch').value.trim();
            
            if (!artistFilter && !songQuery) {
                document.getElementById('matchSongResults').innerHTML = '<div class="no-results">Please enter an artist or song name to search</div>';
                return;
            }
            
            let url = '/songs/api/search?';
            const params = [];
            if (artistFilter) params.push(`artist=${encodeURIComponent(artistFilter)}`);
            if (songQuery) params.push(`song=${encodeURIComponent(songQuery)}`);
            url += params.join('&');
            
            fetch(url)
                .then(r => r.json())
                .then(data => {
                    const container = document.getElementById('matchSongResults');
                    if (!data || data.length === 0) {
                        container.innerHTML = '<div class="no-results">No songs found</div>';
                        return;
                    }
                    container.innerHTML = data.map(s => `
                        <div class="search-result-item" data-id="${s.id}" onclick="selectMatchSong(${s.id}, this)">
                            <div class="result-name">${escapeHtml(s.name)}</div>
                            <div class="result-meta">${escapeHtml(s.artistName || '')}${s.albumName ? ' ‚Ä¢ ' + escapeHtml(s.albumName) : ''}</div>
                        </div>
                    `).join('');
                })
                .catch(err => {
                    console.error('Error searching songs:', err);
                    document.getElementById('matchSongResults').innerHTML = '<div class="no-results">Error searching songs</div>';
                });
        }
        
        function selectMatchSong(id, element) {
            document.querySelectorAll('#matchSongResults .search-result-item').forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');
            matchState.selectedSongId = id;
            document.getElementById('matchAssignBtn').disabled = false;
        }
        
        function assignMatchedSong() {
            if (!matchState.selectedSongId) {
                alert('Please select a song');
                return;
            }
            
            fetch('/scrobbles/api/assign', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    account: matchState.scrobbleData.account || '',
                    artist: matchState.scrobbleData.artist || '',
                    album: matchState.scrobbleData.album || '',
                    song: matchState.scrobbleData.song || '',
                    songId: matchState.selectedSongId
                })
            })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    const importCount = matchState.scrobbleData.cnt || matchState.scrobbleData.count || 0;
                    let msg = `Success! Matched ${data.updatedCount} scrobble(s) to this song.`;
                    if (data.updatedCount > importCount) {
                        msg += `\n(${importCount} from this import + ${data.updatedCount - importCount} previously unmatched)`;
                    }
                    alert(msg);
                    // Refresh list BEFORE closing (so scrobbleData is still available)
                    refreshUnmatchedList();
                    closeMatchModal();
                } else {
                    alert('Error: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(err => {
                console.error('Error assigning song:', err);
                alert('Error assigning song');
            });
        }
        
        function refreshUnmatchedList() {
            // Remove the assigned row from local list and re-render
            if (matchState.scrobbleData) {
                unmatchedList = unmatchedList.filter(r => 
                    !(r.artist === matchState.scrobbleData.artist && 
                      r.album === matchState.scrobbleData.album && 
                      r.song === matchState.scrobbleData.song &&
                      r.account === matchState.scrobbleData.account)
                );
            }
            if (wizardState.scrobbleData) {
                unmatchedList = unmatchedList.filter(r => 
                    !(r.artist === wizardState.scrobbleData.artist && 
                      r.album === wizardState.scrobbleData.album && 
                      r.song === wizardState.scrobbleData.song &&
                      r.account === wizardState.scrobbleData.account)
                );
            }
            renderUnmatchedList();
            
            // Update count display if exists
            const countEl = document.getElementById('unmatchedCount');
            if (countEl) {
                countEl.textContent = unmatchedList.length;
            }
        }

        // ==================== iTunes Fetch Function ====================
        function wizardFetchFromItunes() {
            const button = document.getElementById('wizardFetchItunesBtn');
            const statusEl = document.getElementById('wizardItunesFetchStatus');
            const songName = document.getElementById('wizardSongNameInput').value.trim();
            const artistName = wizardState.selectedArtistName || '';
            const albumName = wizardState.selectedAlbumName === '(Single)' ? '' : (wizardState.selectedAlbumName || '');
            
            if (!songName && !artistName) {
                statusEl.textContent = 'Missing song or artist name for lookup';
                statusEl.style.color = '#ff6b6b';
                return;
            }
            
            // Disable button and show loading state
            const originalText = button.innerHTML;
            button.disabled = true;
            button.innerHTML = '‚è≥ Fetching...';
            statusEl.textContent = '';
            
            fetch('/songs/fetch-itunes-by-fields', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ songName: songName, artistName: artistName, albumName: albumName })
            })
            .then(response => response.json())
            .then(data => {
                button.disabled = false;
                button.innerHTML = originalText;
                
                if (data.success) {
                    // Check if this is a partial match and ask for confirmation
                    if (data.matchType === 'partial') {
                        const confirmMsg = '‚ö†Ô∏è Partial match found (artist + song only, album did not match).\n\n' +
                                         'Do you want to use this data anyway?';
                        if (!confirm(confirmMsg)) {
                            statusEl.textContent = '‚ö†Ô∏è Partial match - Cancelled by user';
                            statusEl.style.color = '#ffa94d';
                            return; // User canceled
                        }
                    }

                    let message = data.matchType === 'partial' ? '‚ö†Ô∏è Partial match - Found in iTunes: ' : '‚úì Found in iTunes: ';
                    const parts = [];
                    
                    // Get album release date (from DB if selected, from input if newly created)
                    let albumReleaseDate = null;
                    if (wizardState.selectedAlbumId) {
                        // TODO: Would need to fetch from server, but for now we'll skip if album exists
                        // For existing albums, we assume the release date might be the same
                        albumReleaseDate = 'unknown'; // Marker to skip population for existing albums
                    } else if (wizardState.isNewAlbum && wizardState.newAlbumReleaseDate) {
                        albumReleaseDate = wizardState.newAlbumReleaseDate;
                    }
                    
                    // Populate release date if found and different from album
                    if (data.releaseDate) {
                        // Convert YYYY-MM-DD to dd/MM/yyyy format
                        const dateParts = data.releaseDate.split('-');
                        if (dateParts.length === 3) {
                            const formatted = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`;
                            
                            // Only populate if no album or if date is different from album
                            if (!albumReleaseDate) {
                                // No album selected - populate normally
                                document.getElementById('wizardSongReleaseDate').value = formatted;
                                parts.push(`Release: ${formatted}`);
                            } else if (albumReleaseDate !== 'unknown' && albumReleaseDate !== formatted) {
                                // New album with different release date - populate
                                document.getElementById('wizardSongReleaseDate').value = formatted;
                                parts.push(`Release: ${formatted} (different from album)`);
                            } else {
                                // Same as album or existing album - skip
                                parts.push(`Release: ${formatted} (skipped - same as album)`);
                            }
                        }
                    }
                    
                    // Populate length if found
                    if (data.lengthSeconds && data.lengthFormatted) {
                        document.getElementById('wizardSongLength').value = data.lengthFormatted;
                        document.getElementById('wizardSongLengthSeconds').value = data.lengthSeconds;
                        parts.push(`Length: ${data.lengthFormatted}`);
                    }
                    
                    if (parts.length > 0) {
                        statusEl.textContent = message + parts.join(', ');
                        statusEl.style.color = data.matchType === 'partial' ? '#ffa94d' : '#69db7c';
                    } else {
                        statusEl.textContent = '‚úì Song found but no date/length available';
                        statusEl.style.color = '#ffa94d';
                    }
                } else {
                    statusEl.textContent = '‚úó ' + (data.message || 'Song not found in iTunes library');
                    statusEl.style.color = '#ff6b6b';
                }
            })
            .catch(error => {
                button.disabled = false;
                button.innerHTML = originalText;
                console.error('Error fetching iTunes data:', error);
                statusEl.textContent = '‚úó Error fetching data from iTunes library';
                statusEl.style.color = '#ff6b6b';
            });
        }

        // ==================== External Fetch for Wizard (uses unified modal in 'both' mode) ====================
        
        function wizardSearchExternalForAlbum() {
            const artistName = wizardState.selectedArtistName || '';
            const albumName = document.getElementById('newAlbumName').value.trim();
            
            if (!artistName && !albumName) {
                document.getElementById('wizardAlbumAppleStatus').textContent = 'Enter album name first';
                document.getElementById('wizardAlbumAppleStatus').style.color = '#ff6b6b';
                return;
            }
            
            // Open unified modal in 'metadata' mode (since album doesn't exist yet, no image to save)
            // But we capture the image URL for later use when album is created
            openExternalFetchModal(artistName, albumName, null, 'album', false, 'metadata', function(selectedItem) {
                const statusEl = document.getElementById('wizardAlbumAppleStatus');
                const parts = [];
                
                // Set release date if available
                if (selectedItem.releaseDate) {
                    const dateParts = selectedItem.releaseDate.split('-');
                    if (dateParts.length === 3) {
                        const formatted = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`;
                        document.getElementById('newAlbumReleaseDate').value = formatted;
                        parts.push('Release: ' + formatted);
                    }
                }
                
                // Store image URL for later use when creating album
                if (selectedItem.url) {
                    document.getElementById('wizardAlbumImageUrl').value = selectedItem.url;
                    document.getElementById('wizardAlbumImagePreviewImg').src = selectedItem.url.replace(/1000x1000|cover_xl/, '300x300').replace('cover_xl', 'cover_medium');
                    document.getElementById('wizardAlbumImagePreview').style.display = 'block';
                    parts.push('Image selected');
                }
                
                // Update status
                if (statusEl) {
                    statusEl.textContent = '‚úì ' + (parts.length > 0 ? parts.join(', ') : 'Selected');
                    statusEl.style.color = '#69db7c';
                }
            });
        }
        
        function wizardSearchExternalForSong() {
            const artistName = wizardState.selectedArtistName || '';
            const songName = document.getElementById('wizardSongNameInput').value.trim();
            const albumName = wizardState.selectedAlbumName === '(Single)' ? '' : (wizardState.selectedAlbumName || '');
            
            if (!artistName && !songName) {
                document.getElementById('wizardItunesFetchStatus').textContent = 'Enter song name first';
                document.getElementById('wizardItunesFetchStatus').style.color = '#ff6b6b';
                return;
            }
            
            const searchTitle = songName || albumName;
            
            // Open unified modal in 'metadata' mode (since song doesn't exist yet, no image to save)
            // But we capture the image URL for later use when song is created
            openExternalFetchModal(artistName, searchTitle, null, 'song', false, 'metadata', function(selectedItem) {
                const statusEl = document.getElementById('wizardItunesFetchStatus');
                const parts = [];
                
                // Set release date if available
                if (selectedItem.releaseDate) {
                    const dateParts = selectedItem.releaseDate.split('-');
                    if (dateParts.length === 3) {
                        const formatted = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`;
                        document.getElementById('wizardSongReleaseDate').value = formatted;
                        parts.push('Release: ' + formatted);
                    }
                }
                
                // Set length if available
                if (selectedItem.lengthSeconds && selectedItem.lengthFormatted) {
                    document.getElementById('wizardSongLength').value = selectedItem.lengthFormatted;
                    document.getElementById('wizardSongLengthSeconds').value = selectedItem.lengthSeconds;
                    parts.push('Length: ' + selectedItem.lengthFormatted);
                }
                
                // Store image URL for later use when creating song
                if (selectedItem.url) {
                    document.getElementById('wizardSongImageUrl').value = selectedItem.url;
                    document.getElementById('wizardSongImagePreviewImg').src = selectedItem.url.replace(/1000x1000|cover_xl/, '300x300').replace('cover_xl', 'cover_medium');
                    document.getElementById('wizardSongImagePreview').style.display = 'block';
                    parts.push('Image selected');
                }
                
                // Update status
                if (statusEl) {
                    statusEl.textContent = '‚úì ' + (parts.length > 0 ? parts.join(', ') : 'Selected');
                    statusEl.style.color = '#69db7c';
                }
            });
        }

        // ==================== Apple Music Search for Wizard (Legacy - kept for reference) ====================
        let wizardAppleSearchResults = [];
        let wizardAppleSearchContext = null; // 'album' or 'song'
        
        function wizardSearchAppleForAlbum() {
            const artistName = wizardState.selectedArtistName || '';
            const albumName = document.getElementById('newAlbumName').value.trim();
            
            if (!artistName && !albumName) {
                document.getElementById('wizardAlbumAppleStatus').textContent = 'Enter album name first';
                document.getElementById('wizardAlbumAppleStatus').style.color = '#ff6b6b';
                return;
            }
            
            wizardAppleSearchContext = 'album';
            openWizardAppleSearchModal(artistName, albumName);
        }
        
        function wizardSearchAppleForSong() {
            const artistName = wizardState.selectedArtistName || '';
            const songName = document.getElementById('wizardSongNameInput').value.trim();
            const albumName = wizardState.selectedAlbumName === '(Single)' ? '' : (wizardState.selectedAlbumName || '');
            
            if (!artistName && !songName) {
                document.getElementById('wizardItunesFetchStatus').textContent = 'Enter song name first';
                document.getElementById('wizardItunesFetchStatus').style.color = '#ff6b6b';
                return;
            }
            
            wizardAppleSearchContext = 'song';
            // For songs, use the song name as the title for searching
            openWizardAppleSearchModal(artistName, songName || albumName);
        }
        
        function openWizardAppleSearchModal(artist, title) {
            // Create modal if it doesn't exist
            let modal = document.getElementById('wizardAppleSearchModal');
            if (!modal) {
                createWizardAppleSearchModal();
                modal = document.getElementById('wizardAppleSearchModal');
            }
            
            // Set search input
            document.getElementById('wizardAppleSearchInput').value = artist + (title ? ' - ' + title : '');
            document.getElementById('wizardAppleSearchResults').innerHTML = '<div class="no-results">Click Search to find results</div>';
            document.getElementById('wizardAppleSearchResults').style.display = 'block';
            
            modal.classList.add('active');
            
            // Auto-search
            performWizardAppleSearch();
        }
        
        function createWizardAppleSearchModal() {
            const modalHtml = `
                <div id="wizardAppleSearchModal" class="unmatched-modal">
                    <div class="unmatched-modal-content" style="max-width: 800px;">
                        <div class="unmatched-modal-header">
                            <h2>Search Apple Music</h2>
                            <span class="unmatched-modal-close" onclick="closeWizardAppleSearchModal()">&times;</span>
                        </div>
                        <div class="unmatched-modal-body">
                            <div class="form-group">
                                <div class="search-row">
                                    <input type="text" autocomplete="off" id="wizardAppleSearchInput" placeholder="Artist - Title" style="flex: 1;">
                                    <select id="wizardAppleCountrySelect" style="width: 120px;">
                                        <option value="us">üá∫üá∏ US</option>
                                        <option value="mx">üá≤üáΩ MX</option>
                                        <option value="es">üá™üá∏ ES</option>
                                        <option value="gb">üá¨üáß UK</option>
                                    </select>
                                    <button type="button" class="btn btn-action" onclick="performWizardAppleSearch()">Search</button>
                                </div>
                            </div>
                            <div id="wizardAppleSearchStatus" style="text-align: center; color: #888; padding: 20px; display: none;">
                                ‚è≥ Searching...
                            </div>
                            <div id="wizardAppleSearchResults" class="wizard-apple-results" style="display: none;">
                            </div>
                        </div>
                        <div class="unmatched-modal-footer">
                            <button type="button" class="btn btn-negative" onclick="closeWizardAppleSearchModal()">Cancel</button>
                        </div>
                    </div>
                </div>
                <style>
                    .wizard-apple-results {
                        display: grid;
                        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
                        gap: 12px;
                        max-height: 400px;
                        overflow-y: auto;
                        padding: 8px;
                    }
                    .wizard-apple-result-item {
                        background: #2a2a2a;
                        border: 2px solid transparent;
                        border-radius: 8px;
                        overflow: hidden;
                        cursor: pointer;
                        transition: all 0.2s;
                    }
                    .wizard-apple-result-item:hover {
                        border-color: rgba(255,255,255,0.3);
                        transform: translateY(-2px);
                    }
                    .wizard-apple-result-item.exact-match {
                        border-color: #4CAF50;
                        box-shadow: 0 0 8px rgba(76, 175, 80, 0.3);
                    }
                    .wizard-apple-result-item.fuzzy-match {
                        border-color: #FF9800;
                        box-shadow: 0 0 8px rgba(255, 152, 0, 0.3);
                    }
                    .wizard-apple-result-img {
                        width: 100%;
                        aspect-ratio: 1;
                        object-fit: cover;
                    }
                    .wizard-apple-result-info {
                        padding: 8px;
                    }
                    .wizard-apple-result-title {
                        font-size: 12px;
                        color: #fff;
                        font-weight: 600;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    }
                    .wizard-apple-result-artist {
                        font-size: 11px;
                        color: #888;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    }
                    .wizard-apple-result-meta {
                        font-size: 10px;
                        color: #9ca3af;
                        margin-top: 4px;
                    }
                    .wizard-apple-result-type {
                        position: absolute;
                        top: 6px;
                        left: 6px;
                        background: rgba(0,0,0,0.7);
                        color: #fff;
                        font-size: 9px;
                        padding: 2px 5px;
                        border-radius: 3px;
                        text-transform: uppercase;
                    }
                    .wizard-apple-match-badge {
                        position: absolute;
                        top: 6px;
                        right: 6px;
                        font-size: 8px;
                        padding: 2px 6px;
                        border-radius: 3px;
                        font-weight: 600;
                        text-transform: uppercase;
                    }
                    .wizard-apple-match-badge.exact { background: #4CAF50; color: #fff; }
                    .wizard-apple-match-badge.fuzzy { background: #FF9800; color: #fff; }
                </style>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }
        
        function closeWizardAppleSearchModal() {
            const modal = document.getElementById('wizardAppleSearchModal');
            if (modal) modal.classList.remove('active');
        }
        
        function performWizardAppleSearch() {
            const searchInput = document.getElementById('wizardAppleSearchInput').value.trim();
            const country = document.getElementById('wizardAppleCountrySelect').value;
            
            if (!searchInput) return;
            
            const statusEl = document.getElementById('wizardAppleSearchStatus');
            const resultsEl = document.getElementById('wizardAppleSearchResults');
            
            statusEl.style.display = 'block';
            resultsEl.style.display = 'none';
            
            // Parse search
            const parts = searchInput.split(' - ');
            const artist = parts[0] || searchInput;
            const title = parts.length > 1 ? parts.slice(1).join(' - ') : parts[0];
            
            fetch(`/api/apple-music/search?artist=${encodeURIComponent(artist)}&title=${encodeURIComponent(title)}&country=${country}`)
                .then(r => r.json())
                .then(data => {
                    statusEl.style.display = 'none';
                    
                    if (!data || data.length === 0) {
                        resultsEl.innerHTML = '<div class="no-results">No results found. Try different search terms.</div>';
                        resultsEl.style.display = 'block';
                        return;
                    }
                    
                    // Sort by match quality
                    wizardAppleSearchResults = sortWizardAppleResults(data, artist, title);
                    
                    // Render results
                    resultsEl.innerHTML = wizardAppleSearchResults.map((item, idx) => {
                        const matchClass = item.matchType === 'exact' ? 'exact-match' : item.matchType === 'fuzzy' ? 'fuzzy-match' : '';
                        const matchBadge = item.matchType === 'exact' ? '<span class="wizard-apple-match-badge exact">Exact</span>' :
                                          item.matchType === 'fuzzy' ? '<span class="wizard-apple-match-badge fuzzy">Close</span>' : '';
                        // Format release date
                        let releaseDateDisplay = '';
                        if (item.releaseDate) {
                            const d = new Date(item.releaseDate + 'T00:00:00');
                            releaseDateDisplay = d.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
                        }
                        const metaLine = [releaseDateDisplay, item.lengthFormatted].filter(x => x).join(' ‚Ä¢ ');
                        return `
                            <div class="wizard-apple-result-item ${matchClass}" style="position: relative;" 
                                 onclick="selectWizardAppleResult(${idx})">
                                <span class="wizard-apple-result-type">${item.type}</span>
                                ${matchBadge}
                                <img class="wizard-apple-result-img" src="${item.thumbnailUrl}" alt="${escapeHtml(item.title)}" loading="lazy">
                                <div class="wizard-apple-result-info">
                                    <div class="wizard-apple-result-title" title="${escapeHtml(item.title)}">${escapeHtml(item.title)}</div>
                                    <div class="wizard-apple-result-artist" title="${escapeHtml(item.artistName)}">${escapeHtml(item.artistName)}</div>
                                    ${metaLine ? `<div class="wizard-apple-result-meta">${metaLine}</div>` : ''}
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    resultsEl.style.display = 'grid';
                })
                .catch(err => {
                    console.error('Apple search error:', err);
                    statusEl.style.display = 'none';
                    resultsEl.innerHTML = '<div class="no-results">Error searching Apple Music</div>';
                    resultsEl.style.display = 'block';
                });
        }
        
        function sortWizardAppleResults(results, searchArtist, searchTitle) {
            const normArtist = normalizeForMatchWizard(searchArtist);
            const normTitle = normalizeForMatchWizard(searchTitle);
            const fuzzyTitle = removeVariationKeywordsWizard(searchTitle);
            
            return results.map(item => {
                const itemArtist = normalizeForMatchWizard(item.artistName);
                const itemTitle = normalizeForMatchWizard(item.title);
                const itemTitleFuzzy = removeVariationKeywordsWizard(item.title);
                
                let score = 0;
                let matchType = 'none';
                
                if (itemArtist === normArtist && itemTitle === normTitle) {
                    score = 1000;
                    matchType = 'exact';
                } else if (itemArtist === normArtist && itemTitleFuzzy === fuzzyTitle && fuzzyTitle) {
                    score = 950;
                    matchType = 'fuzzy';
                } else if (itemArtist === normArtist) {
                    score = 500;
                    matchType = 'artist';
                } else if (itemTitle === normTitle) {
                    score = 400;
                    matchType = 'title';
                } else if (itemArtist.includes(normArtist) || normArtist.includes(itemArtist)) {
                    score = 200;
                } else if (itemTitle.includes(normTitle) || normTitle.includes(itemTitle)) {
                    score = 100;
                }
                
                return { ...item, matchScore: score, matchType: matchType };
            }).sort((a, b) => b.matchScore - a.matchScore);
        }
        
        function normalizeForMatchWizard(str) {
            if (!str) return '';
            return str.toLowerCase().trim().replace(/[^a-z0-9]/g, '');
        }
        
        function removeVariationKeywordsWizard(str) {
            if (!str) return '';
            const keywords = ['deluxe', 'remaster', 'remastered', 'anniversary', 'special', 'revised', 'edition', 'version', 'expanded', 'bonus', 'explicit', 'clean'];
            let normalized = str.toLowerCase();
            keywords.forEach(keyword => {
                normalized = normalized.replace(new RegExp(keyword, 'g'), '');
            });
            normalized = normalized.replace(/\d+(st|nd|rd|th)?/g, '');
            return normalized.trim().replace(/[^a-z0-9]/g, '');
        }
        
        function selectWizardAppleResult(index) {
            const item = wizardAppleSearchResults[index];
            if (!item) return;
            
            if (wizardAppleSearchContext === 'album') {
                // Populate album form
                if (item.releaseDate) {
                    // Convert YYYY-MM-DD to dd/MM/yyyy
                    const parts = item.releaseDate.split('-');
                    if (parts.length === 3) {
                        document.getElementById('newAlbumReleaseDate').value = `${parts[2]}/${parts[1]}/${parts[0]}`;
                    }
                }
                // Store image URL for later saving
                if (item.fullUrl) {
                    document.getElementById('wizardAlbumImageUrl').value = item.fullUrl;
                    document.getElementById('wizardAlbumImagePreviewImg').src = item.thumbnailUrl;
                    document.getElementById('wizardAlbumImagePreview').style.display = 'block';
                    wizardState.newAlbumImageUrl = item.fullUrl;
                }
                document.getElementById('wizardAlbumAppleStatus').textContent = '‚úì Selected: ' + item.title;
                document.getElementById('wizardAlbumAppleStatus').style.color = '#69db7c';
            } else if (wizardAppleSearchContext === 'song') {
                // Populate song form
                const statusEl = document.getElementById('wizardItunesFetchStatus');
                const parts = [];
                
                if (item.releaseDate) {
                    const dateParts = item.releaseDate.split('-');
                    if (dateParts.length === 3) {
                        const formatted = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`;
                        document.getElementById('wizardSongReleaseDate').value = formatted;
                        parts.push(`Release: ${formatted}`);
                    }
                }
                if (item.lengthSeconds && item.lengthFormatted) {
                    document.getElementById('wizardSongLength').value = item.lengthFormatted;
                    document.getElementById('wizardSongLengthSeconds').value = item.lengthSeconds;
                    parts.push(`Length: ${item.lengthFormatted}`);
                }
                // Store image URL
                if (item.fullUrl) {
                    document.getElementById('wizardSongImageUrl').value = item.fullUrl;
                    document.getElementById('wizardSongImagePreviewImg').src = item.thumbnailUrl;
                    document.getElementById('wizardSongImagePreview').style.display = 'block';
                    wizardState.newSongImageUrl = item.fullUrl;
                }
                
                if (parts.length > 0) {
                    statusEl.textContent = 'Selected: ' + parts.join(', ');
                    statusEl.style.color = '#69db7c';
                }
            }
            
            closeWizardAppleSearchModal();
        }

        // ==================== Utility Functions ====================
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeJs(text) {
            if (!text) return '';
            return text.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"');
        }

        // ==================== Spotify Search for Wizard ====================
        let wizardSpotifySearchResults = [];
        let wizardSpotifySearchContext = null; // 'album' or 'song'
        
        function wizardSearchSpotifyForAlbum() {
            const artistName = wizardState.selectedArtistName || '';
            const albumName = document.getElementById('newAlbumName').value.trim();
            
            if (!artistName && !albumName) {
                document.getElementById('wizardAlbumAppleStatus').textContent = 'Enter album name first';
                document.getElementById('wizardAlbumAppleStatus').style.color = '#ff6b6b';
                return;
            }
            
            wizardSpotifySearchContext = 'album';
            openWizardSpotifySearchModal(artistName, albumName);
        }
        
        function wizardSearchSpotifyForSong() {
            const artistName = wizardState.selectedArtistName || '';
            const songName = document.getElementById('wizardSongNameInput').value.trim();
            const albumName = wizardState.selectedAlbumName === '(Single)' ? '' : (wizardState.selectedAlbumName || '');
            
            if (!artistName && !songName) {
                document.getElementById('wizardItunesFetchStatus').textContent = 'Enter song name first';
                document.getElementById('wizardItunesFetchStatus').style.color = '#ff6b6b';
                return;
            }
            
            wizardSpotifySearchContext = 'song';
            openWizardSpotifySearchModal(artistName, songName || albumName);
        }
        
        function openWizardSpotifySearchModal(artist, title) {
            // Create modal if it doesn't exist
            let modal = document.getElementById('wizardSpotifySearchModal');
            if (!modal) {
                createWizardSpotifySearchModal();
                modal = document.getElementById('wizardSpotifySearchModal');
            }
            
            // Set search input
            document.getElementById('wizardSpotifySearchInput').value = artist + (title ? ' - ' + title : '');
            document.getElementById('wizardSpotifySearchResults').innerHTML = '<div class="no-results">Click Search to find results</div>';
            document.getElementById('wizardSpotifySearchResults').style.display = 'block';
            
            modal.classList.add('active');
            
            // Auto-search
            performWizardSpotifySearch();
        }
        
        function createWizardSpotifySearchModal() {
            const modalHtml = `
                <div id="wizardSpotifySearchModal" class="unmatched-modal">
                    <div class="unmatched-modal-content" style="max-width: 800px;">
                        <div class="unmatched-modal-header" style="border-bottom-color: rgba(30, 215, 96, 0.3);">
                            <h2><span style="color: #1DB954;">‚óè</span> Search Spotify</h2>
                            <span class="unmatched-modal-close" onclick="closeWizardSpotifySearchModal()">&times;</span>
                        </div>
                        <div class="unmatched-modal-body">
                            <div class="form-group">
                                <div class="search-row">
                                    <input type="text" autocomplete="off" id="wizardSpotifySearchInput" placeholder="Artist - Title" style="flex: 1;">
                                    <select id="wizardSpotifyCountrySelect" style="width: 120px;">
                                        <option value="US">üá∫üá∏ US</option>
                                        <option value="MX">üá≤üáΩ MX</option>
                                        <option value="ES">üá™üá∏ ES</option>
                                        <option value="GB">üá¨üáß UK</option>
                                    </select>
                                    <button type="button" class="btn btn-action btn-spotify-wizard" onclick="performWizardSpotifySearch()">Search</button>
                                </div>
                            </div>
                            <div id="wizardSpotifySearchStatus" style="text-align: center; color: #888; padding: 20px; display: none;">
                                ‚è≥ Searching...
                            </div>
                            <div id="wizardSpotifySearchResults" class="wizard-spotify-results" style="display: none;">
                            </div>
                        </div>
                        <div class="unmatched-modal-footer">
                            <button type="button" class="btn btn-negative" onclick="closeWizardSpotifySearchModal()">Cancel</button>
                        </div>
                    </div>
                </div>
                <style>
                    .btn-spotify-wizard {
                        background-color: #1a472d !important;
                        color: #1DB954 !important;
                        border: 1px solid #1DB954 !important;
                    }
                    .btn-spotify-wizard:hover {
                        background-color: #1DB954 !important;
                        color: #fff !important;
                    }
                    .wizard-spotify-results {
                        display: grid;
                        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
                        gap: 12px;
                        max-height: 400px;
                        overflow-y: auto;
                        padding: 8px;
                    }
                    .wizard-spotify-result-item {
                        background: #2a2a2a;
                        border: 2px solid transparent;
                        border-radius: 8px;
                        overflow: hidden;
                        cursor: pointer;
                        transition: all 0.2s;
                    }
                    .wizard-spotify-result-item:hover {
                        border-color: rgba(30, 215, 96, 0.5);
                        transform: translateY(-2px);
                    }
                    .wizard-spotify-result-item.exact-match {
                        border-color: #1DB954;
                        box-shadow: 0 0 8px rgba(30, 215, 96, 0.3);
                    }
                    .wizard-spotify-result-item.fuzzy-match {
                        border-color: #FF9800;
                        box-shadow: 0 0 8px rgba(255, 152, 0, 0.3);
                    }
                    .wizard-spotify-result-img {
                        width: 100%;
                        aspect-ratio: 1;
                        object-fit: cover;
                    }
                    .wizard-spotify-result-info {
                        padding: 8px;
                    }
                    .wizard-spotify-result-title {
                        font-size: 12px;
                        color: #fff;
                        font-weight: 600;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    }
                    .wizard-spotify-result-artist {
                        font-size: 11px;
                        color: #888;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    }
                    .wizard-spotify-result-meta {
                        font-size: 10px;
                        color: #9ca3af;
                        margin-top: 4px;
                    }
                    .wizard-spotify-result-type {
                        position: absolute;
                        top: 6px;
                        left: 6px;
                        background: rgba(30, 215, 96, 0.9);
                        color: #fff;
                        font-size: 9px;
                        padding: 2px 5px;
                        border-radius: 3px;
                        text-transform: uppercase;
                    }
                    .wizard-spotify-match-badge {
                        position: absolute;
                        top: 6px;
                        right: 6px;
                        font-size: 8px;
                        padding: 2px 6px;
                        border-radius: 3px;
                        font-weight: 600;
                        text-transform: uppercase;
                    }
                    .wizard-spotify-match-badge.exact { background: #1DB954; color: #fff; }
                    .wizard-spotify-match-badge.fuzzy { background: #FF9800; color: #fff; }
                </style>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }
        
        function closeWizardSpotifySearchModal() {
            const modal = document.getElementById('wizardSpotifySearchModal');
            if (modal) modal.classList.remove('active');
        }
        
        function performWizardSpotifySearch() {
            const searchInput = document.getElementById('wizardSpotifySearchInput').value.trim();
            const market = document.getElementById('wizardSpotifyCountrySelect').value;
            
            if (!searchInput) return;
            
            const statusEl = document.getElementById('wizardSpotifySearchStatus');
            const resultsEl = document.getElementById('wizardSpotifySearchResults');
            
            statusEl.style.display = 'block';
            resultsEl.style.display = 'none';
            
            // Parse search
            const parts = searchInput.split(' - ');
            const artist = parts[0] || searchInput;
            const title = parts.length > 1 ? parts.slice(1).join(' - ') : parts[0];
            
            fetch(`/api/spotify/search?artist=${encodeURIComponent(artist)}&title=${encodeURIComponent(title)}&market=${market}`)
                .then(r => r.json())
                .then(data => {
                    statusEl.style.display = 'none';
                    
                    if (!data || data.length === 0) {
                        resultsEl.innerHTML = '<div class="no-results">No results found. Try different search terms.</div>';
                        resultsEl.style.display = 'block';
                        return;
                    }
                    
                    // Sort by match quality (reuse the same logic)
                    wizardSpotifySearchResults = sortWizardAppleResults(data, artist, title);
                    
                    // Render results
                    resultsEl.innerHTML = wizardSpotifySearchResults.map((item, idx) => {
                        const matchClass = item.matchType === 'exact' ? 'exact-match' : item.matchType === 'fuzzy' ? 'fuzzy-match' : '';
                        const matchBadge = item.matchType === 'exact' ? '<span class="wizard-spotify-match-badge exact">Exact</span>' :
                                          item.matchType === 'fuzzy' ? '<span class="wizard-spotify-match-badge fuzzy">Close</span>' : '';
                        // Format release date
                        let releaseDateDisplay = '';
                        if (item.releaseDate) {
                            const d = new Date(item.releaseDate + 'T00:00:00');
                            releaseDateDisplay = d.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
                        }
                        const metaLine = [releaseDateDisplay, item.lengthFormatted].filter(x => x).join(' ‚Ä¢ ');
                        return `
                            <div class="wizard-spotify-result-item ${matchClass}" style="position: relative;" 
                                 onclick="selectWizardSpotifyResult(${idx})">
                                <span class="wizard-spotify-result-type">${item.type}</span>
                                ${matchBadge}
                                <img class="wizard-spotify-result-img" src="${item.thumbnailUrl}" alt="${escapeHtml(item.title)}" loading="lazy">
                                <div class="wizard-spotify-result-info">
                                    <div class="wizard-spotify-result-title" title="${escapeHtml(item.title)}">${escapeHtml(item.title)}</div>
                                    <div class="wizard-spotify-result-artist" title="${escapeHtml(item.artistName)}">${escapeHtml(item.artistName)}</div>
                                    ${metaLine ? `<div class="wizard-spotify-result-meta">${metaLine}</div>` : ''}
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    resultsEl.style.display = 'grid';
                })
                .catch(err => {
                    console.error('Spotify search error:', err);
                    statusEl.style.display = 'none';
                    resultsEl.innerHTML = '<div class="no-results">Error searching Spotify. Make sure API is configured.</div>';
                    resultsEl.style.display = 'block';
                });
        }
        
        function selectWizardSpotifyResult(index) {
            const item = wizardSpotifySearchResults[index];
            if (!item) return;
            
            if (wizardSpotifySearchContext === 'album') {
                // Populate album form
                if (item.releaseDate) {
                    // Convert YYYY-MM-DD to dd/MM/yyyy
                    const parts = item.releaseDate.split('-');
                    if (parts.length === 3) {
                        document.getElementById('newAlbumReleaseDate').value = `${parts[2]}/${parts[1]}/${parts[0]}`;
                    }
                }
                // Store image URL for later saving
                if (item.fullUrl) {
                    document.getElementById('wizardAlbumImageUrl').value = item.fullUrl;
                    document.getElementById('wizardAlbumImagePreviewImg').src = item.thumbnailUrl;
                    document.getElementById('wizardAlbumImagePreview').style.display = 'block';
                    wizardState.newAlbumImageUrl = item.fullUrl;
                }
                document.getElementById('wizardAlbumAppleStatus').textContent = '‚úì Selected from Spotify: ' + item.title;
                document.getElementById('wizardAlbumAppleStatus').style.color = '#1DB954';
            } else if (wizardSpotifySearchContext === 'song') {
                // Populate song form
                const statusEl = document.getElementById('wizardItunesFetchStatus');
                const parts = [];
                
                if (item.releaseDate) {
                    const dateParts = item.releaseDate.split('-');
                    if (dateParts.length === 3) {
                        const formatted = `${dateParts[2]}/${dateParts[1]}/${dateParts[0]}`;
                        document.getElementById('wizardSongReleaseDate').value = formatted;
                        parts.push(`Release: ${formatted}`);
                    }
                }
                if (item.lengthSeconds && item.lengthFormatted) {
                    document.getElementById('wizardSongLength').value = item.lengthFormatted;
                    document.getElementById('wizardSongLengthSeconds').value = item.lengthSeconds;
                    parts.push(`Length: ${item.lengthFormatted}`);
                }
                // Store image URL
                if (item.fullUrl) {
                    document.getElementById('wizardSongImageUrl').value = item.fullUrl;
                    document.getElementById('wizardSongImagePreviewImg').src = item.thumbnailUrl;
                    document.getElementById('wizardSongImagePreview').style.display = 'block';
                    wizardState.newSongImageUrl = item.fullUrl;
                }
                
                if (parts.length > 0) {
                    statusEl.textContent = 'From Spotify: ' + parts.join(', ');
                    statusEl.style.color = '#1DB954';
                }
            }
            
            closeWizardSpotifySearchModal();
        }
    </script>
</body>
</html>
